/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "Forbids commented code",
      category: "Possible Errors",
      recommended: true,
    },
    fixable: "code",
    schema: [], // no options
  },
  create: function (context) {
    const sourceCode = context.getSourceCode();
    // Retrieves all comments from the source code.
    const comments = sourceCode.getAllComments();

    // Clones the parser options from the context and ensures loc/range are enabled for parsing snippets.
    const currentParserOptions = {
      ...context.parserOptions, // Spread to allow modification if needed
      loc: true, // Ensure loc data is generated by the parser
      range: true, // Ensure range data is generated by the parser
    };

    // Parses a string of content using the project's configured ESLint parser.
    // Falls back to 'espree' if no specific parser is configured.
    function parseContentInternal(contentToParse, options) {
      if (context.parserPath) {
        try {
          const parser = require(context.parserPath);
          return parser.parse(contentToParse, options);
        } catch (error) {
          // If the configured parser fails on the snippet, re-throw.
          // The main logic will catch this and potentially try wrapping.
          throw error;
        }
      } else {
        // Fallback to espree if no parserPath is specified (ESLint's default parser)
        const espree = require("espree");
        return espree.parse(contentToParse, {
          ...options, // Pass through options like ecmaVersion, sourceType
          // Ensure espree-specific options if any, or rely on common ones.
          // ecmaVersion and sourceType should be in options from currentParserOptions.
        });
      }
    }

    // Checks if an AST Program node has an empty body.
    function hasEmptyBody(program) {
      return program.type === "Program" && program.body.length === 0;
    }

    // Checks if an AST Program node consists only of "trivial" statements.
    // A program is trivial if all its body statements are ExpressionStatements containing trivial expressions.
    function isTrivialProgram(program) {
      return (
        program.type === "Program" &&
        program.body.every(
          (statement) =>
            statement.type === "ExpressionStatement" &&
            isTrivialExpression(statement.expression)
        )
      );
    }

    // Determines if an AST expression node is "trivial".
    // Trivial expressions are simple constructs (e.g., identifiers, literals)
    // or compositions of other trivial expressions that are unlikely to be actual commented-out code.
    function isTrivialExpression(node) {
      if (!node) {
        return false;
      }
      switch (node.type) {
        case "Identifier":
        case "Literal":
        case "TemplateLiteral":
          // e.g., `hello`, `${world}` (if inner expressions are trivial)
          return true;
        case "MemberExpression":
          // e.g., foo.bar, foo[bar]

          return (
            isTrivialExpression(node.object) &&
            (!node.computed || isTrivialExpression(node.property))
          );
        case "CallExpression": {
          // e.g., func(), obj.method()
          // Specific check for "PascalCase(PascalCase)" pattern, often used for descriptive comments.

          const callee = node.callee;
          // Allow "PascalCaseName(PascalCaseArgument)" as trivial, e.g., "Notification(Receiving)"
          if (callee.type === "Identifier" && /^[A-Z]/.test(callee.name)) {
            if (
              node.arguments.length === 1 &&
              node.arguments[0].type === "Identifier" &&
              /^[A-Z]/.test(node.arguments[0].name)
            ) {
              return true;
            }
          }
          return false; // Other CallExpressions are non-trivial
        }
        case "UnaryExpression":
          // e.g., !isValid, +count
          return isTrivialExpression(node.argument);
        case "BinaryExpression":
          // BinaryExpressions like "a !== b" are generally non-trivial for commented code.
          // Allow 'in' operator with simple operands as potentially trivial,
          // to handle cases like "// variabili in errore".
          // Other BinaryExpressions (like comparisons, arithmetic) are generally non-trivial.
          return node.operator === 'in' && isTrivialExpression(node.left) && isTrivialExpression(node.right);
        
        case "LogicalExpression":
          // LogicalExpressions like "enabled && visible" are generally non-trivial.
          return false;
        case "AssignmentExpression":
          // AssignmentExpressions like "isActive = true" are generally non-trivial.
          return false;
        case "SequenceExpression":
          return node.expressions.every(isTrivialExpression);
        case "ArrowFunctionExpression": {
          // According to tests like "// $VARIABILE$ => VARIABILE" (invalid),
          // any successfully parsed ArrowFunctionExpression is considered non-trivial.
          return false;
        }
        case "TaggedTemplateExpression":
          // e.g., String.raw`foo
          return (
            isTrivialExpression(node.tag) && isTrivialExpression(node.quasi)
          );
        default:
          return false;
      }
    }

    // Checks if an AST Program node represents a "trivial" LabeledStatement.
    // A LabeledStatement is trivial if its label is not 'case' or 'default' (handled by regex)
    // and its body is a trivial expression. Special handling for "$VAR$: IDENTIFIER" patterns.
    function hasLabeledStatementBody(program) {
      if (
        program.type === "Program" &&
        program.body.length === 1 &&
        program.body[0].type === "LabeledStatement"
      ) {
        const statement = program.body[0];
        const labelName = statement.label.name;
        const bodyExpression =
          statement.body.type === "ExpressionStatement"
            ? statement.body.expression
            : null;

        // 'case' and 'default' labels are handled by a specific regex check earlier in the rule.
        // If it's a LabeledStatement that isn't 'case' or 'default':
        if (labelName !== "case" && labelName !== "default") {
          // If the label is like $VAR$ and body is a simple Identifier (e.g., "// $FOO$: BAR"),
          // it's considered non-trivial (commented code) as per test expectations.
          if (
            labelName.startsWith("$") &&
            labelName.endsWith("$") &&
            bodyExpression &&
            bodyExpression.type === "Identifier"
          ) {
            return false; // Makes it non-trivial, leading to a report.
          }
          // Otherwise, if the body is trivial (e.g. "// myLabel: 123"), the LabeledStatement is trivial.
          return bodyExpression && isTrivialExpression(bodyExpression);
        }
      }
      return false; // Default to false if not a single LabeledStatement fitting the criteria.
    }

    // Checks if a comment string matches common patterns for editor region markers.
    // e.g., "#region", "#endregion"
    function isRegionComment(content) {
      return /\s*#(end)?region/.test(content);
    }

    // Processes an array of comment tokens and groups consecutive line comments
    // into single "blocks" of text. Block comments are treated as individual blocks.
    function toBlocks(commentsToProcess) {
      const blocks = [];
      let prevLine;
      for (const comment of commentsToProcess) {
        if (comment.type === "Block") {
          blocks.push({
            // Trim the raw value, parsers usually handle leading/trailing space in content.
            content: comment.value
              .replace(/^\s*\*/, "")
              .replace(/\n\s*\*/g, "\n"),
            loc: { ...comment.loc },
          });
          // Reset prevLine as a block comment breaks sequence of line comments
          prevLine = undefined;
        } else if (comment.type === "Line") {
          const trimmedValue = comment.value.trim(); // Trim line comment value
          // Check if current line comment is consecutive to the previous one
          if (
            prevLine &&
            prevLine.loc.start.line === comment.loc.start.line - 1
          ) {
            const prevBlock = blocks[blocks.length - 1];
            prevBlock.content += `\n${trimmedValue}`;
            prevBlock.loc.end = comment.loc.end;
          } else {
            blocks.push({
              content: trimmedValue,
              loc: { ...comment.loc },
            });
          }
          prevLine = comment;
        }
      }
      return blocks;
    }

    // Wraps comment content in a syntactic context based on the AST node
    // where the comment was found. This helps in parsing ambiguous comment snippets.
    function wrapContent(content, node) {
      switch (node?.type) {
        case "ArrayExpression":
          return `let wrapper = [${content}]`;
        case "ClassBody":
          return `class Wrapper { ${content} }`;
        case "ImportDeclaration":
          return `import { ${content} } from "wrapper"`;
        case "ObjectExpression":
          return `let wrapper = { ${content} }`;
        case "FunctionDeclaration":
          return `function wrapper(${content}) {}`;
        case "SwitchStatement":
          return `switch (wrapper) { ${content} }`;
        case "TSInterfaceBody":
          return `interface Wrapper { ${content} }`;
        case "TSTypeLiteral":
          return `type Wrapper = { ${content} }`;
        default:
          return undefined;
      }
    }

    return {
      Program: function () {
        // Get comment blocks
        const blocks = toBlocks(comments);
        for (const block of blocks) {
          const { content: rawContent, loc } = block;
          const content = rawContent.trim(); // Use trimmed content for checks

          // Define the fix function for the current block.
          // This function will be passed to context.report if an issue is found.
          const fix = (fixer) => {
            const startIndex = sourceCode.getIndexFromLoc(loc.start);
            const endIndex = sourceCode.getIndexFromLoc(loc.end);
            // Ensure the range is valid before attempting to remove.
            return fixer.removeRange([startIndex, endIndex]);
          };

          // Comments for collapsible regions can be parsed as private
          // properties within class declarations, but they're not
          // commented-out code.
          if (isRegionComment(content)) {
            continue;
          }

          // Early check for commented 'case' or 'default' statements using a regex.
          // This is a specific pattern often found in commented-out switch logic.
          if (/(?:^|\s)(?:case\s+[^:]*:|default\s*:)/.test(content)) {
            context.report({ loc, message: "Code commented forbidden", fix });
            continue;
          }

          // Attempt to parse the comment content directly.
          // If it parses into a "trivial" program, it's likely not actual commented code.
          try {
            const program = parseContentInternal(content, currentParserOptions);
            if (
              !hasEmptyBody(program) && // Empty program is trivial
              !isTrivialProgram(program) && // Program with only trivial expressions is trivial
              !hasLabeledStatementBody(program)
            ) {
              context.report({
                loc,
                message: "Code commented forbidden",
                fix,
              });
            }
            continue; // Successfully parsed and considered trivial, move to next block
          } catch (error) {
            // Direct parsing failed.
            // Heuristic: If content ends with common binary/logical operators (preceded by space),
            // it might be an incomplete but intentional piece of commented code (e.g., "// enabled &&").
            if (/\s(&&|\|\||[!=]==?|\*|\+|\/|-|%)\s*$/.test(content)) {
              context.report({ loc, message: "Code commented forbidden", fix });
              continue;
            }
          }

          // Comments within certain nodes - e.g. class declarations - need to
          // be wrapped in a similar syntactic context to determine whether or not they
          // are commented-out code.
          const index = sourceCode.getIndexFromLoc(loc.start);
          const nodeAtCommentStart = sourceCode.getNodeByRangeIndex(index);
          const wrappedContent = wrapContent(content, nodeAtCommentStart);
          if (wrappedContent) {
            try {
              parseContentInternal(wrappedContent, currentParserOptions); // Check if wrapped content parses
              context.report({
                // If it parses successfully when wrapped, it's considered commented-out code.
                loc,
                message: "Code commented forbidden",
                fix,
              });
            } catch (error) {
              // If parsing the wrapped content also fails, do nothing.
            }
          }
        }
      },
    };
  },
};
