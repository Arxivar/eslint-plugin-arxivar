/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "Forbids commented code",
      category: "Possible Errors",
      recommended: true,
    },
    fixable: "code",
    schema: [], // no options
  },
  create: function (context) {
    const sourceCode = context.getSourceCode();
    const comments = sourceCode.getAllComments();
    const currentParserOptions = {
      ...context.parserOptions, // Spread to allow modification if needed
      loc: true, // Ensure loc data is generated by the parser
      range: true, // Ensure range data is generated by the parser
    };

    // Function to parse comment content using the project's configured parser or a fallback
    function parseContentInternal(contentToParse, options) {
      if (context.parserPath) {
        try {
          const parser = require(context.parserPath);
          return parser.parse(contentToParse, options);
        } catch (error) {
          // If the configured parser fails on the snippet, re-throw.
          // The main logic will catch this and potentially try wrapping.
          throw error;
        }
      } else {
        // Fallback to espree if no parserPath is specified (ESLint's default parser)
        const espree = require("espree");
        return espree.parse(contentToParse, {
          ...options, // Pass through options like ecmaVersion, sourceType
          // Ensure espree-specific options if any, or rely on common ones.
          // ecmaVersion and sourceType should be in options from currentParserOptions.
        });
      }
    }

    function hasEmptyBody(program) {
      return program.type === "Program" && program.body.length === 0;
    }

    function hasExpressionBody(program) {
      return (
        program.type === "Program" &&
        program.body.every(
          (statement) =>
            statement.type === "ExpressionStatement" &&
            isExpressionOrIdentifierOrLiteral(statement.expression)
        )
      );
    }

    function hasLabeledStatementBody(program) {
      return (
        program.type === "Program" &&
        program.body.length === 1 &&
        program.body[0].type === "LabeledStatement"
      );
    }

    function isExpressionOrIdentifierOrLiteral(node) {
      if (node.type === "Identifier") {
        return true;
      }
      if (node.type === "Literal") {
        return true;
      }
      if (node.type === "BinaryExpression") {
        return (
          isExpressionOrIdentifierOrLiteral(node.left) &&
          isExpressionOrIdentifierOrLiteral(node.right)
        );
      }
      return false;
    }

    function isRegionComment(content) {
      return /\s*#(end)?region/.test(content);
    }

    function toBlocks(commentsToProcess) {
      const blocks = [];
      let prevLine;
      for (const comment of commentsToProcess) {
        if (comment.type === "Block") {
          blocks.push({
            // Trim the raw value, parsers usually handle leading/trailing space in content.
            content: comment.value
              .replace(/^\s*\*/, "")
              .replace(/\n\s*\*/g, "\n"),
            loc: { ...comment.loc },
          });
          prevLine = undefined;
        } else if (comment.type === "Line") {
          const trimmedValue = comment.value.trim(); // Trim line comment value
          if (
            prevLine &&
            prevLine.loc.start.line === comment.loc.start.line - 1
          ) {
            const prevBlock = blocks[blocks.length - 1];
            prevBlock.content += `\n${trimmedValue}`;
            prevBlock.loc.end = comment.loc.end;
          } else {
            blocks.push({
              content: trimmedValue,
              loc: { ...comment.loc }
            });
          }
          prevLine = comment;
        }
      }
      return blocks;
    }

    function wrapContent(content, node) {
      switch (node?.type) {
        case "ArrayExpression":
          return `let wrapper = [${content}]`;
        case "ClassBody":
          return `class Wrapper { ${content} }`;
        case "ImportDeclaration":
          return `import { ${content} } from "wrapper"`;
        case "ObjectExpression":
          return `let wrapper = { ${content} }`;
        case "FunctionDeclaration":
          return `function wrapper(${content}) {}`;
        case "SwitchStatement":
          return `switch (wrapper) { ${content} }`;
        case "TSInterfaceBody":
          return `interface Wrapper { ${content} }`;
        case "TSTypeLiteral":
          return `type Wrapper = { ${content} }`;
        default:
          return undefined;
      }
    }

    return {
      Program: function () {
        const blocks = toBlocks(comments);
        for (const block of blocks) {
          const { content, loc } = block;

          // Comments for collapsible regions can be parsed as private
          // properties within class declarations, but they're not
          // commented-out code.
          if (isRegionComment(content.trim())) { // Trim content for region check
            continue;
          }

          // If the comment can be parsed as a trivial program, it's probably
          // not commented-out code.
          try {
            const program = parseContentInternal(content, currentParserOptions);
            if (
              !hasEmptyBody(program) &&
              !hasExpressionBody(program) &&
              !hasLabeledStatementBody(program)
            ) {
              context.report({
                loc,
                message: "Code commented forbidden",
              });
            }
            continue; // Successfully parsed and evaluated, move to next block
          } catch (error) {
            // Parsing failed, proceed to try wrapping
          }

          // Comments within certain nodes - e.g. class declarations - need to
          // be wrapped in a similar context to determine whether or not they
          // are commented-out code.
          const index = sourceCode.getIndexFromLoc(loc.start);
          const nodeAtCommentStart = sourceCode.getNodeByRangeIndex(index);
          const wrappedContent = wrapContent(content, nodeAtCommentStart);
          if (wrappedContent) {
            try {
              parseContentInternal(wrappedContent, currentParserOptions); // Check if wrapped content parses
              context.report({
                loc,
                message: "Code commented forbidden",
              });
            } catch (error) {}
          }
        }
      },
    };
  },
};
