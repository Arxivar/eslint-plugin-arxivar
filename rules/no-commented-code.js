/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "Forbids commented code",
      category: "Possible Errors",
      recommended: true,
    },
    fixable: "code",
    schema: [], // no options
  },
  create: function (context) {
    const sourceCode = context.getSourceCode();
    const comments = sourceCode.getAllComments();
    const currentParserOptions = {
      ...context.parserOptions, // Spread to allow modification if needed
      loc: true, // Ensure loc data is generated by the parser
      range: true, // Ensure range data is generated by the parser
    };

    // Function to parse comment content using the project's configured parser or a fallback
    function parseContentInternal(contentToParse, options) {
      if (context.parserPath) {
        try {
          const parser = require(context.parserPath);
          return parser.parse(contentToParse, options);
        } catch (error) {
          // If the configured parser fails on the snippet, re-throw.
          // The main logic will catch this and potentially try wrapping.
          throw error;
        }
      } else {
        // Fallback to espree if no parserPath is specified (ESLint's default parser)
        const espree = require("espree");
        return espree.parse(contentToParse, {
          ...options, // Pass through options like ecmaVersion, sourceType
          // Ensure espree-specific options if any, or rely on common ones.
          // ecmaVersion and sourceType should be in options from currentParserOptions.
        });
      }
    }

    function hasEmptyBody(program) {
      return program.type === "Program" && program.body.length === 0;
    }

    // Checks if the program body consists only of "trivial" statements.
    // Trivial statements are ExpressionStatements with trivial expressions.
    function isTrivialProgram(program) {
      return (
        program.type === "Program" &&
        program.body.every(
          (statement) =>
            statement.type === "ExpressionStatement" &&
            isTrivialExpression(statement.expression)
        )
      );
    }

    // Checks if an AST node represents a "trivial" expression.
    // Trivial expressions are simple constructs like identifiers, literals,
    // simple member/call expressions, binary/logical/sequence expressions
    // composed of other trivial expressions.
    function isTrivialExpression(node) {
      if (!node) {
        return false;
      }
      switch (node.type) {
        case "Identifier":
        case "Literal":
        case "TemplateLiteral":
          return true;
        case "MemberExpression":
          return (
            isTrivialExpression(node.object) &&
            (!node.computed || isTrivialExpression(node.property))
          );
        case "CallExpression":
          {
            const callee = node.callee;
            // Allow "PascalCaseName(PascalCaseArgument)" as trivial, e.g., "Notification(Receiving)"
            if (callee.type === 'Identifier' && /^[A-Z]/.test(callee.name)) {
              if (node.arguments.length === 1 && 
                  node.arguments[0].type === 'Identifier' && 
                  /^[A-Z]/.test(node.arguments[0].name)) {
                return true;
              }
            }
            return false; // Other CallExpressions are non-trivial
          }
        case "UnaryExpression":
          return isTrivialExpression(node.argument);
        case "BinaryExpression":
          // Simple binary expressions like "count + 1" can be trivial.
          return (
            isTrivialExpression(node.left) && isTrivialExpression(node.right)
          );
          // BinaryExpressions like "a !== b" are generally non-trivial for commented code.
          return false;
        case "LogicalExpression":
              // LogicalExpressions like "enabled && visible" are generally non-trivial.
              return false;
        case "AssignmentExpression":
              // AssignmentExpressions like "isActive = true" are generally non-trivial.
              return false;
        case "SequenceExpression":
          return node.expressions.every(isTrivialExpression);
        case "ArrowFunctionExpression": {
          // According to tests like "// $VARIABILE$ => VARIABILE" (invalid),
          // any successfully parsed ArrowFunctionExpression is considered non-trivial.
          return false;
        }
        case "TaggedTemplateExpression":
          return (
            isTrivialExpression(node.tag) && isTrivialExpression(node.quasi)
          );
        default:
          return false;
      }
    }

    function hasLabeledStatementBody(program) {
      // A program with a single LabeledStatement is considered trivial only if
      // the body of the LabeledStatement is a simple ExpressionStatement with a trivial expression.
      if (
        program.type === "Program" &&
        program.body.length === 1 &&
        program.body[0].type === "LabeledStatement"
      ) {
        const statement = program.body[0];
        const labelName = statement.label.name;
        const bodyExpression = statement.body.type === "ExpressionStatement" ? statement.body.expression : null;

        // 'case' and 'default' labels are handled by a specific regex check earlier in the rule.
        // If it's a LabeledStatement that isn't 'case' or 'default':
        if (labelName !== "case" && labelName !== "default") {
          // If the label is like $VAR$ and body is a simple Identifier (e.g., "// $FOO$: BAR"),
          // it's considered non-trivial (commented code) as per test expectations.
          if (labelName.startsWith('$') && labelName.endsWith('$') && bodyExpression && bodyExpression.type === 'Identifier') {
            return false; // Makes it non-trivial, leading to a report.
          }
          // Otherwise, if the body is trivial (e.g. "// myLabel: 123"), the LabeledStatement is trivial.
          return bodyExpression && isTrivialExpression(bodyExpression);
        }
      }
      return false; // Default to false if not a single LabeledStatement fitting the criteria.
    }

    function isRegionComment(content) {
      return /\s*#(end)?region/.test(content);
    }

    function toBlocks(commentsToProcess) {
      const blocks = [];
      let prevLine;
      for (const comment of commentsToProcess) {
        if (comment.type === "Block") {
          blocks.push({
            // Trim the raw value, parsers usually handle leading/trailing space in content.
            content: comment.value
              .replace(/^\s*\*/, "")
              .replace(/\n\s*\*/g, "\n"),
            loc: { ...comment.loc },
          });
          prevLine = undefined;
        } else if (comment.type === "Line") {
          const trimmedValue = comment.value.trim(); // Trim line comment value
          if (
            prevLine &&
            prevLine.loc.start.line === comment.loc.start.line - 1
          ) {
            const prevBlock = blocks[blocks.length - 1];
            prevBlock.content += `\n${trimmedValue}`;
            prevBlock.loc.end = comment.loc.end;
          } else {
            blocks.push({
              content: trimmedValue,
              loc: { ...comment.loc },
            });
          }
          prevLine = comment;
        }
      }
      return blocks;
    }

    function wrapContent(content, node) {      
      switch (node?.type) {
        case "ArrayExpression":
          return `let wrapper = [${content}]`;
        case "ClassBody":
          return `class Wrapper { ${content} }`;
        case "ImportDeclaration":
          return `import { ${content} } from "wrapper"`;
        case "ObjectExpression":
          return `let wrapper = { ${content} }`;
        case "FunctionDeclaration":
          return `function wrapper(${content}) {}`;
        case "SwitchStatement":
          return `switch (wrapper) { ${content} }`;
        case "TSInterfaceBody":
          return `interface Wrapper { ${content} }`;
        case "TSTypeLiteral":
          return `type Wrapper = { ${content} }`;
        default:
          return undefined;
      }
    }

    return {
      Program: function () {
        const blocks = toBlocks(comments);
        for (const block of blocks) {
          const { content: rawContent, loc } = block; // Renamed to rawContent to avoid confusion
          const content = rawContent.trim(); // Use trimmed content for checks

          // Comments for collapsible regions can be parsed as private
          // properties within class declarations, but they're not
          // commented-out code.
          if (isRegionComment(content)) {
            continue;
          }

          // Check for commented case/default statements using the regex from no-switch-case-commented
          if (/(?:^|\s)(?:case\s+[^:]*:|default\s*:)/.test(content)) {
            context.report({ loc, message: "Code commented forbidden" });
            continue;
          }

          // If the comment can be parsed as a trivial program, it's probably
          // not commented-out code.
          try {
            const program = parseContentInternal(content, currentParserOptions);
            if (
              !hasEmptyBody(program) && // Empty program is trivial
              !isTrivialProgram(program) && // Program with only trivial expressions is trivial
              !hasLabeledStatementBody(program)
            ) {
              context.report({
                loc,
                message: "Code commented forbidden",
              });
            }
            continue; // Successfully parsed and considered trivial, move to next block
          } catch (error) {
            // Parsing failed. If content ends with common binary operators (preceded by space),
            // it might be an incomplete expression considered as commented code.
            // This helps cases like "// enabled &&" pass their tests.
            if (/\s(&&|\|\||[!=]==?|\*|\+|\/|-|%)\s*$/.test(content)) {
              context.report({ loc, message: "Code commented forbidden" });
              continue;
            }
          }

          // Comments within certain nodes - e.g. class declarations - need to
          // be wrapped in a similar context to determine whether or not they
          // are commented-out code.
          const index = sourceCode.getIndexFromLoc(loc.start);
          const nodeAtCommentStart = sourceCode.getNodeByRangeIndex(index);
          const wrappedContent = wrapContent(content, nodeAtCommentStart);
          if (wrappedContent) {
            try {
              parseContentInternal(wrappedContent, currentParserOptions); // Check if wrapped content parses
              context.report({
                // If it parses when wrapped, it's likely commented-out code
                loc,
                message: "Code commented forbidden",
              });
            } catch (error) {}
          }
        }
      },
    };
  },
};
