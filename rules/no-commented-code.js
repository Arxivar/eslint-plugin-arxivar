/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "Forbids commented code",
      category: "Possible Errors",
      recommended: true,
    },
    fixable: "code",
    schema: [], // no options
  },
  create: function (context) {
    const sourceCode = context.getSourceCode();
    const comments = sourceCode.getAllComments();
    const currentParserOptions = {
      ...context.parserOptions, // Spread to allow modification if needed
      loc: true, // Ensure loc data is generated by the parser
      range: true, // Ensure range data is generated by the parser
    };

    // Function to parse comment content using the project's configured parser or a fallback
    function parseContentInternal(contentToParse, options) {
      if (context.parserPath) {
        try {
          const parser = require(context.parserPath);
          return parser.parse(contentToParse, options);
        } catch (error) {
          // If the configured parser fails on the snippet, re-throw.
          // The main logic will catch this and potentially try wrapping.
          throw error;
        }
      } else {
        // Fallback to espree if no parserPath is specified (ESLint's default parser)
        const espree = require("espree");
        return espree.parse(contentToParse, {
          ...options, // Pass through options like ecmaVersion, sourceType
          // Ensure espree-specific options if any, or rely on common ones.
          // ecmaVersion and sourceType should be in options from currentParserOptions.
        });
      }
    }

    function hasEmptyBody(program) {
      return program.type === "Program" && program.body.length === 0;
    }

    // Checks if the program body consists only of "trivial" statements.
    // Trivial statements are ExpressionStatements with trivial expressions.
    function isTrivialProgram(program) {
      return (
        program.type === "Program" &&
        program.body.every(
          (statement) =>
            statement.type === "ExpressionStatement" &&
            isTrivialExpression(statement.expression)
        )
      );
    }

    // Checks if an AST node represents a "trivial" expression.
    // Trivial expressions are simple constructs like identifiers, literals,
    // simple member/call expressions, binary/logical/sequence expressions
    // composed of other trivial expressions.
    function isTrivialExpression(node) {
      if (!node) {
        return false;
      }
      switch (node.type) {
        case "Identifier":
        case "Literal":
        case "TemplateLiteral":
          return true;
        case "MemberExpression":
          return (
            isTrivialExpression(node.object) &&
            (!node.computed || isTrivialExpression(node.property))
          );
        case "CallExpression":
          return (
            isTrivialExpression(node.callee) &&
            node.arguments.every(isTrivialExpression)
          );
        case "UnaryExpression":
          return isTrivialExpression(node.argument);
        case "BinaryExpression":
        case "LogicalExpression":
        case "AssignmentExpression":
          return (
            isTrivialExpression(node.left) && isTrivialExpression(node.right)
          );
        case "SequenceExpression":
          return node.expressions.every(isTrivialExpression);
        case "ArrowFunctionExpression": {
          // An ArrowFunctionExpression is trivial if its params are identifiers
          // and its body is a simple identifier or a simple member expression (e.g., item.id).
          const paramsAreIdentifiers = node.params.every(
            (p) => p.type === "Identifier"
          );
          let bodyIsSimple = false;
          if (node.body.type === "Identifier") {
            bodyIsSimple = true;
          } else if (
            node.body.type === "MemberExpression" &&
            node.body.object.type === "Identifier" &&
            node.body.property.type === "Identifier" &&
            !node.body.computed
          ) {
            bodyIsSimple = true;
          }
          return paramsAreIdentifiers && bodyIsSimple;
        }
        case "TaggedTemplateExpression":
          return (
            isTrivialExpression(node.tag) && isTrivialExpression(node.quasi)
          );
        default:
          return false;
      }
    }

    function hasLabeledStatementBody(program) {
      // A program with a single LabeledStatement is considered trivial only if
      // the body of the LabeledStatement is a simple ExpressionStatement with a trivial expression.
      if (
        program.type === "Program" &&
        program.body.length === 1 &&
        program.body[0].type === "LabeledStatement"
      ) {
        const statement = program.body[0];
        // A LabeledStatement is trivial only if its label is NOT 'case' or 'default',
        // and its body is an ExpressionStatement with a trivial expression.
        return (
          statement.label.name !== "case" &&
          statement.label.name !== "default" &&
          statement.body.type === "ExpressionStatement" &&
          isTrivialExpression(statement.body.expression)
        );
      }
      return false;
    }

    function isRegionComment(content) {
      return /\s*#(end)?region/.test(content);
    }

    function toBlocks(commentsToProcess) {
      const blocks = [];
      let prevLine;
      for (const comment of commentsToProcess) {
        if (comment.type === "Block") {
          blocks.push({
            // Trim the raw value, parsers usually handle leading/trailing space in content.
            content: comment.value
              .replace(/^\s*\*/, "")
              .replace(/\n\s*\*/g, "\n"),
            loc: { ...comment.loc },
          });
          prevLine = undefined;
        } else if (comment.type === "Line") {
          const trimmedValue = comment.value.trim(); // Trim line comment value
          if (
            prevLine &&
            prevLine.loc.start.line === comment.loc.start.line - 1
          ) {
            const prevBlock = blocks[blocks.length - 1];
            prevBlock.content += `\n${trimmedValue}`;
            prevBlock.loc.end = comment.loc.end;
          } else {
            blocks.push({
              content: trimmedValue,
              loc: { ...comment.loc },
            });
          }
          prevLine = comment;
        }
      }
      return blocks;
    }

    function wrapContent(content, node) {      
      switch (node?.type) {
        case "ArrayExpression":
          return `let wrapper = [${content}]`;
        case "ClassBody":
          return `class Wrapper { ${content} }`;
        case "ImportDeclaration":
          return `import { ${content} } from "wrapper"`;
        case "ObjectExpression":
          return `let wrapper = { ${content} }`;
        case "FunctionDeclaration":
          return `function wrapper(${content}) {}`;
        case "SwitchStatement":
          return `switch (wrapper) { ${content} }`;
        case "TSInterfaceBody":
          return `interface Wrapper { ${content} }`;
        case "TSTypeLiteral":
          return `type Wrapper = { ${content} }`;
        default:
          return undefined;
      }
    }

    return {
      Program: function () {
        const blocks = toBlocks(comments);
        for (const block of blocks) {
          const { content: rawContent, loc } = block; // Renamed to rawContent to avoid confusion
          const content = rawContent.trim(); // Use trimmed content for checks

          // Comments for collapsible regions can be parsed as private
          // properties within class declarations, but they're not
          // commented-out code.
          if (isRegionComment(content)) {
            continue;
          }

          // Check for commented case/default statements using the regex from no-switch-case-commented
          if (/(?:^|\s)(?:case\s+[^:]*:|default\s*:)/.test(content)) {
            context.report({ loc, message: "Code commented forbidden" });
            continue;
          }

          // If the comment can be parsed as a trivial program, it's probably
          // not commented-out code.
          try {
            const program = parseContentInternal(content, currentParserOptions);
            if (
              !hasEmptyBody(program) && // Empty program is trivial
              !isTrivialProgram(program) && // Program with only trivial expressions is trivial
              !hasLabeledStatementBody(program)
            ) {
              context.report({
                loc,
                message: "Code commented forbidden",
              });
            }
            continue; // Successfully parsed and considered trivial, move to next block
          } catch (error) {
            // Parsing failed, proceed to try wrapping
          }

          // Comments within certain nodes - e.g. class declarations - need to
          // be wrapped in a similar context to determine whether or not they
          // are commented-out code.
          const index = sourceCode.getIndexFromLoc(loc.start);
          const nodeAtCommentStart = sourceCode.getNodeByRangeIndex(index);
          const wrappedContent = wrapContent(content, nodeAtCommentStart);
          if (wrappedContent) {
            try {
              parseContentInternal(wrappedContent, currentParserOptions); // Check if wrapped content parses
              context.report({
                // If it parses when wrapped, it's likely commented-out code
                loc,
                message: "Code commented forbidden",
              });
            } catch (error) {}
          }
        }
      },
    };
  },
};
