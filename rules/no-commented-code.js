/** @type {import('eslint').Rule.RuleModule} */
module.exports = {
  meta: {
    type: "problem",
    docs: {
      description: "Forbids commented code",
      category: "Possible Errors",
      recommended: true,
    },
    fixable: "code",
    schema: [], // no options
  },
  create: function (context) {
    // ESLint 9 uses context.sourceCode, ESLint 8 uses context.getSourceCode()
    // ESLint 9 uses context.filename, ESLint 8 uses context.getFilename()
    // ESLint 9 uses context.languageOptions.parserOptions, ESLint 8 uses context.parserOptions
    const isESLint9Plus = !!context.languageOptions;

    const sourceCode = isESLint9Plus
      ? context.sourceCode
      : context.getSourceCode();
    const filename = isESLint9Plus ? context.filename : context.getFilename();
    const baseParserOptions =
      (isESLint9Plus
        ? context.languageOptions?.parserOptions
        : context.parserOptions) || {};

    // Retrieves all comments from the source code.
    const comments = sourceCode.getAllComments();

    // Clones the parser options from the context and ensures loc/range are enabled for parsing snippets.
    const currentParserOptions = {
      ...baseParserOptions,
      loc: true, // Ensure loc data is generated by the parser
      range: true, // Ensure range data is generated by the parser
    };

    // Parses a string of content using the project's configured ESLint parser.
    // Falls back to 'espree' if no specific parser is configured.
    function parseContentInternal(contentToParse, options) {
      if (isESLint9Plus) {
        const parser = context.languageOptions?.parser;
        if (parser && typeof parser.parseForESLint === "function") {
          // For @typescript-eslint/parser, parseForESLint is preferred and needs filePath for project-based features
          const result = parser.parseForESLint(contentToParse, {
            ...options,
            filePath: filename,
          });
          return result.ast;
        }
        if (parser && typeof parser.parse === "function") {
          // Generic parse method on the parser object
          // Include filePath if project is configured, as some parsers (like @typescript-eslint/parser's .parse) can use it.
          const parseOpts = options.project
            ? { ...options, filePath: filename }
            : options;
          const result = parser.parse(contentToParse, parseOpts);
          // Some parsers (like espree) return AST directly, @typescript-eslint/parser's .parse returns { ast, services }
          return result && result.ast ? result.ast : result;
        }
      } else {
        // ESLint 8 or older style
        // Try ESLint 8 style: context.parserServices.parseForESLint (for @typescript-eslint/parser)
        if (
          context.parserServices &&
          typeof context.parserServices.parseForESLint === "function"
        ) {
          const result = context.parserServices.parseForESLint(contentToParse, {
            ...options,
            filePath: filename,
          });
          return result.ast;
        }
        // Try ESLint 8 style: context.parserPath (for parsers specified by path)
        if (context.parserPath) {
          const parser = require(context.parserPath);
          return parser.parse(contentToParse, options);
        }
      }

      // Ultimate fallback to espree if no specific parser logic above was met or if they threw an error
      // (errors are caught by the caller of parseContentInternal)
      // This ensures that if the primary configured parser fails on the snippet (e.g. TS syntax in a JS file
      // without TS parser configured for it), espree still gets a chance if the snippet is plain JS.
      // However, if the configured parser *should* have parsed it (e.g. TS syntax with TS parser),
      // an error from the primary parser is more informative and will be handled by the try/catch in the main loop.
      // This fallback is more for when no specific parser was identified from the context.
      const espree = require("espree");
      return espree.parse(contentToParse, {
        ...options,
      });
    }

    // Checks if an AST Program node has an empty body.
    function hasEmptyBody(program) {
      return program.type === "Program" && program.body.length === 0;
    }

    // Checks if an AST Program node consists only of "trivial" statements.
    // A program is trivial if all its body statements are ExpressionStatements containing trivial expressions.
    function isTrivialProgram(program) {
      return (
        program.type === "Program" &&
        program.body.every(
          (statement) =>
            statement.type === "ExpressionStatement" &&
            isTrivialExpression(statement.expression)
        )
      );
    }

    // Determines if an AST expression node is "trivial".
    // Trivial expressions are simple constructs (e.g., identifiers, literals)
    // or compositions of other trivial expressions that are unlikely to be actual commented-out code.
    function isTrivialExpression(node) {
      if (!node) {
        return false;
      }
      switch (node.type) {
        case "Identifier":
        case "Literal":
        case "TemplateLiteral":
          // e.g., `hello`, `${world}` (if inner expressions are trivial)
          return true;
        case "MemberExpression":
          // e.g., foo.bar, foo[bar]

          return (
            isTrivialExpression(node.object) &&
            (!node.computed || isTrivialExpression(node.property))
          );
        case "CallExpression": {
          // e.g., func(), obj.method()
          // Allow CallExpression with a Literal callee if arguments are trivial.
          // This handles cases like "1(enumService)" which parsers interpret as a CallExpression.
          // If a comment parses as any other CallExpression and wasn't caught by
          // the specific "identifier <space> (identifier)" regex, it's likely actual commented-out code.
          const callee = node.callee;
          if (
            callee.type === "Literal" &&
            node.arguments.every(isTrivialExpression)
          ) {
            return true;
          }
          // Otherwise, most CallExpressions are considered non-trivial (commented-out code).
          return false;
        }
        case "UnaryExpression":
          // e.g., !isValid, +count
          return isTrivialExpression(node.argument);
        case "BinaryExpression":
          // BinaryExpressions like "a !== b" are generally non-trivial for commented code.
          // Allow 'in' operator with simple operands as potentially trivial,
          // to handle cases like "// variabili in errore".
          // Other BinaryExpressions (like comparisons, arithmetic) are generally non-trivial.
          return (
            node.operator === "in" &&
            isTrivialExpression(node.left) &&
            isTrivialExpression(node.right)
          );

        case "LogicalExpression":
          // LogicalExpressions like "enabled && visible" are generally non-trivial.
          return false;
        case "AssignmentExpression":
          // AssignmentExpressions like "isActive = true" are generally non-trivial.
          return false;
        case "SequenceExpression":
          return node.expressions.every(isTrivialExpression);
        case "ArrowFunctionExpression": {
          // According to tests like "// $VARIABILE$ => VARIABILE" (invalid),
          // any successfully parsed ArrowFunctionExpression is considered non-trivial.
          return false;
        }
        case "TaggedTemplateExpression":
          // e.g., String.raw`foo
          return (
            isTrivialExpression(node.tag) && isTrivialExpression(node.quasi)
          );
        default:
          return false;
      }
    }

    // Checks if an AST Program node represents a "trivial" LabeledStatement.
    // A LabeledStatement is trivial if its label is not 'case' or 'default' (handled by regex)
    // and its body is a trivial expression. Special handling for "$VAR$: IDENTIFIER" patterns.
    function hasLabeledStatementBody(program) {
      if (
        program.type === "Program" &&
        program.body.length === 1 &&
        program.body[0].type === "LabeledStatement"
      ) {
        const statement = program.body[0];
        const labelName = statement.label.name;
        const bodyExpression =
          statement.body.type === "ExpressionStatement"
            ? statement.body.expression
            : null;

        // 'case' and 'default' labels are handled by a specific regex check earlier in the rule.
        // If it's a LabeledStatement that isn't 'case' or 'default':
        if (labelName !== "case" && labelName !== "default") {
          // If the label is like $VAR$ and body is a simple Identifier (e.g., "// $FOO$: BAR"),
          // it's considered non-trivial (commented code) as per test expectations.
          if (
            labelName.startsWith("$") &&
            labelName.endsWith("$") &&
            bodyExpression &&
            bodyExpression.type === "Identifier"
          ) {
            return false; // Makes it non-trivial, leading to a report.
          }
          // Otherwise, if the body is trivial (e.g. "// myLabel: 123"), the LabeledStatement is trivial.
          return bodyExpression && isTrivialExpression(bodyExpression);
        }
      }
      return false; // Default to false if not a single LabeledStatement fitting the criteria.
    }

    // Checks if a comment string matches common patterns for editor region markers.
    // e.g., "#region", "#endregion"
    function isRegionComment(content) {
      return /\s*#(end)?region/.test(content);
    }

    // Processes an array of comment tokens and groups consecutive line comments
    // into single "blocks" of text. Block comments are treated as individual blocks.
    function toBlocks(commentsToProcess) {
      const blocks = [];
      let prevLine;
      for (const comment of commentsToProcess) {
        if (comment.type === "Block") {
          const isJSDoc = comment.value.startsWith("*");
          let processedValue = comment.value;
          // Remove initial space/asterisk if it's a JSDoc-like line start
          processedValue = processedValue.replace(/^\s*\*/, "");
          // Remove leading space/asterisks from subsequent newlines
          processedValue = processedValue.replace(/\n\s*\*/g, "\n");
          // Remove trailing space/asterisk if it's from a JSDoc-like line end (e.g., " ... *")
          processedValue = processedValue.replace(/\s*\*$/, "");
          blocks.push({
            content: processedValue,
            loc: { ...comment.loc },
            isJSDoc,
          });
          // Reset prevLine as a block comment breaks sequence of line comments
          prevLine = undefined;
        } else if (comment.type === "Line") {
          const trimmedValue = comment.value.trim(); // Trim line comment value
          // Check if current line comment is consecutive to the previous one
          if (
            prevLine &&
            prevLine.loc.start.line === comment.loc.start.line - 1
          ) {
            const prevBlock = blocks[blocks.length - 1];
            prevBlock.content += `\n${trimmedValue}`;
            prevBlock.loc.end = comment.loc.end;
          } else {
            blocks.push({
              content: trimmedValue,
              loc: { ...comment.loc },
              isJSDoc: false, // Line comments are not JSDoc
            });
          }
          prevLine = comment;
        }
      }
      return blocks;
    }

    // Wraps comment content in a syntactic context based on the AST node
    // where the comment was found. This helps in parsing ambiguous comment snippets.
    function wrapContent(content, node) {
      switch (node?.type) {
        case "ArrayExpression":
          return `let wrapper = [${content}]`;
        case "ClassBody":
          return `class Wrapper { ${content} }`;
        case "ImportDeclaration":
          return `import { ${content} } from "wrapper"`;
        case "ObjectExpression":
          return `let wrapper = { ${content} }`;
        case "FunctionDeclaration":
          return `function wrapper(${content}) {}`;
        case "SwitchStatement":
          return `switch (wrapper) { ${content} }`;
        case "TSInterfaceBody":
          return `interface Wrapper { ${content} }`;
        case "TSTypeLiteral":
          return `type Wrapper = { ${content} }`;
        default:
          return undefined;
      }
    }

    return {
      Program: function () {
        // Get comment blocks
        const blocks = toBlocks(comments);
        for (const block of blocks) {
          const { content: rawContent, loc, isJSDoc } = block;

          if (isJSDoc) {
            continue; // Skip JSDoc comments, their content is ignored
          }

          const content = rawContent.trim(); // Use trimmed content for checks

          // Define the fix function for the current block.
          // This function will be passed to context.report if an issue is found.
          const fix = (fixer) => {
            const startIndex = sourceCode.getIndexFromLoc(loc.start);
            const endIndex = sourceCode.getIndexFromLoc(loc.end);
            // Ensure the range is valid before attempting to remove.
            return fixer.removeRange([startIndex, endIndex]);
          };

          // Comments for collapsible regions can be parsed as private
          // properties within class declarations, but they're not
          // commented-out code.
          if (isRegionComment(content)) {
            continue;
          }

          // Specific pattern for "identifier<space>(identifier)" to be simple text.
          // This handles cases like "// word (description)" which might otherwise be parsed as non-trivial calls,
          // distinguishing them from "word(codeCall)" by the presence of a space.
          // Regex matches: IDENTIFIER<one-or-more-spaces>(IDENTIFIER)
          const descriptiveIdentifierCallPattern =
            /^[a-zA-Z_$][\w$]*\s+\([a-zA-Z_$][\w$]*\)$/;
          if (descriptiveIdentifierCallPattern.test(content)) {
            continue; // Treat as valid simple text
          }

          // Early check for commented 'case' or 'default' statements using a regex.
          // This is a specific pattern often found in commented-out switch logic.
          // The case condition part ([^:\s]+(?:\s+[^:\s]+){0,1}) allows for up to 4 space-separated tokens
          // (e.g., "case 'some string with spaces':" or "case MY_CONSTANT_VALUE:")
          // to avoid matching long natural language sentences containing "case ... :".
          const caseOrDefaultRegex =
            /(?:^|\s)(?:case\s+([^:\s]+(?:\s+[^:\s]+){0,1})\s*:|default\s*:)/;
          if (caseOrDefaultRegex.test(content)) {
            context.report({ loc, message: "Code commented forbidden", fix });
            continue;
          }

          // Attempt to parse the comment content directly.
          // If it parses into a "trivial" program, it's likely not actual commented code.
          try {
            const program = parseContentInternal(content, currentParserOptions);
            if (
              !hasEmptyBody(program) && // Empty program is trivial
              !isTrivialProgram(program) && // Program with only trivial expressions is trivial
              !hasLabeledStatementBody(program)
            ) {
              context.report({
                loc,
                message: "Code commented forbidden",
                fix,
              });
            }
            continue; // Successfully parsed and considered trivial, move to next block
          } catch (error) {
            // Direct parsing failed.
            // Heuristic: If content ends with common binary/logical operators (preceded by space),
            // it might be an incomplete but intentional piece of commented code (e.g., "// enabled &&").
            if (/\s(&&|\|\||[!=]==?|\*|\+|\/|-|%)\s*$/.test(content)) {
              context.report({ loc, message: "Code commented forbidden", fix });
              continue;
            }
          }

          // Comments within certain nodes - e.g. class declarations - need to
          // be wrapped in a similar syntactic context to determine whether or not they
          // are commented-out code.
          const index = sourceCode.getIndexFromLoc(loc.start);
          const nodeAtCommentStart = sourceCode.getNodeByRangeIndex(index);
          const wrappedContent = wrapContent(content, nodeAtCommentStart);
          if (wrappedContent) {
            try {
              const wrappedProgram = parseContentInternal(
                wrappedContent,
                currentParserOptions
              ); // Check if wrapped content parses
              // If it parses successfully when wrapped, check if it's also non-trivial.
              if (
                !hasEmptyBody(wrappedProgram) &&
                !isTrivialProgram(wrappedProgram) &&
                !hasLabeledStatementBody(wrappedProgram) // Assuming this check is also relevant for wrapped content
              ) {
                context.report({
                  loc,
                  message: "Code commented forbidden",
                  fix,
                });
              }
            } catch (wrapError) {
              // If parsing the wrapped content also fails, do nothing.
            }
          }
        }
      },
    };
  },
};
